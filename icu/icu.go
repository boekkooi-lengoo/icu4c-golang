// WARNING: This file has automatically been generated on Thu, 18 Apr 2024 08:45:55 CEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package icu

/*
#cgo pkg-config: icu-i18n icu-io icu-uc
#cgo LDFLAGS: -licuuc -licudata
#include <unicode/utypes.h>
#include <unicode/utext.h>
#include <unicode/ubrk.h>
#include <unicode/uclean.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// breakOpen function as declared in unicode/ubrk.h:244
func breakOpen(Type breakIteratorType, locale string, text []uint16, textLength int32, status *errorCode) *breakIterator {
	cType, cTypeAllocMap := (C.UBreakIteratorType)(Type), cgoAllocsUnknown
	locale = safeString(locale)
	clocale, clocaleAllocMap := unpackPCharString(locale)
	ctext, ctextAllocMap := copyPCharBytes((*sliceHeader)(unsafe.Pointer(&text)))
	ctextLength, ctextLengthAllocMap := (C.int32_t)(textLength), cgoAllocsUnknown
	cstatus, cstatusAllocMap := (*C.UErrorCode)(unsafe.Pointer(status)), cgoAllocsUnknown
	__ret := C.ubrk_open_74(cType, clocale, ctext, ctextLength, cstatus)
	runtime.KeepAlive(cstatusAllocMap)
	runtime.KeepAlive(ctextLengthAllocMap)
	runtime.KeepAlive(ctextAllocMap)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(clocaleAllocMap)
	runtime.KeepAlive(cTypeAllocMap)
	__v := *(**breakIterator)(unsafe.Pointer(&__ret))
	return __v
}

// breakClone function as declared in unicode/ubrk.h:336
func breakClone(bi *breakIterator, status *errorCode) *breakIterator {
	cbi, cbiAllocMap := (*C.UBreakIterator)(unsafe.Pointer(bi)), cgoAllocsUnknown
	cstatus, cstatusAllocMap := (*C.UErrorCode)(unsafe.Pointer(status)), cgoAllocsUnknown
	__ret := C.ubrk_clone_74(cbi, cstatus)
	runtime.KeepAlive(cstatusAllocMap)
	runtime.KeepAlive(cbiAllocMap)
	__v := *(**breakIterator)(unsafe.Pointer(&__ret))
	return __v
}

// breakClose function as declared in unicode/ubrk.h:357
func breakClose(bi *breakIterator) {
	cbi, cbiAllocMap := (*C.UBreakIterator)(unsafe.Pointer(bi)), cgoAllocsUnknown
	C.ubrk_close_74(cbi)
	runtime.KeepAlive(cbiAllocMap)
}

// breakSetText function as declared in unicode/ubrk.h:415
func breakSetText(bi *breakIterator, text *text, status *errorCode) {
	cbi, cbiAllocMap := (*C.UBreakIterator)(unsafe.Pointer(bi)), cgoAllocsUnknown
	ctext, ctextAllocMap := text.PassRef()
	cstatus, cstatusAllocMap := (*C.UErrorCode)(unsafe.Pointer(status)), cgoAllocsUnknown
	C.ubrk_setUText_74(cbi, ctext, cstatus)
	runtime.KeepAlive(cstatusAllocMap)
	runtime.KeepAlive(ctextAllocMap)
	runtime.KeepAlive(cbiAllocMap)
}

// breakNext function as declared in unicode/ubrk.h:442
func breakNext(bi *breakIterator) int32 {
	cbi, cbiAllocMap := (*C.UBreakIterator)(unsafe.Pointer(bi)), cgoAllocsUnknown
	__ret := C.ubrk_next_74(cbi)
	runtime.KeepAlive(cbiAllocMap)
	__v := (int32)(__ret)
	return __v
}

// breakGetRuleStatus function as declared in unicode/ubrk.h:550
func breakGetRuleStatus(bi *breakIterator) int32 {
	cbi, cbiAllocMap := (*C.UBreakIterator)(unsafe.Pointer(bi)), cgoAllocsUnknown
	__ret := C.ubrk_getRuleStatus_74(cbi)
	runtime.KeepAlive(cbiAllocMap)
	__v := (int32)(__ret)
	return __v
}

// icuInit function as declared in unicode/uclean.h:53
func icuInit(status *errorCode) {
	cstatus, cstatusAllocMap := (*C.UErrorCode)(unsafe.Pointer(status)), cgoAllocsUnknown
	C.u_init_74(cstatus)
	runtime.KeepAlive(cstatusAllocMap)
}

// Cleanup function as declared in unicode/uclean.h:102
func Cleanup() {
	C.u_cleanup_74()
}

// textClose function as declared in unicode/utext.h:183
func textClose(ut *text) *text {
	cut, cutAllocMap := ut.PassRef()
	__ret := C.utext_close_74(cut)
	runtime.KeepAlive(cutAllocMap)
	__v := newTextRef(unsafe.Pointer(__ret))
	return __v
}

// textOpenUTF8 function as declared in unicode/utext.h:207
func textOpenUTF8(ut *text, s string, length int64, status *errorCode) *text {
	cut, cutAllocMap := ut.PassRef()
	s = safeString(s)
	cs, csAllocMap := unpackPCharString(s)
	clength, clengthAllocMap := (C.int64_t)(length), cgoAllocsUnknown
	cstatus, cstatusAllocMap := (*C.UErrorCode)(unsafe.Pointer(status)), cgoAllocsUnknown
	__ret := C.utext_openUTF8_74(cut, cs, clength, cstatus)
	runtime.KeepAlive(cstatusAllocMap)
	runtime.KeepAlive(clengthAllocMap)
	runtime.KeepAlive(s)
	runtime.KeepAlive(csAllocMap)
	runtime.KeepAlive(cutAllocMap)
	__v := newTextRef(unsafe.Pointer(__ret))
	return __v
}

// errorName function as declared in unicode/utypes.h:726
func errorName(code errorCode) string {
	ccode, ccodeAllocMap := (C.UErrorCode)(code), cgoAllocsUnknown
	__ret := C.u_errorName_74(ccode)
	runtime.KeepAlive(ccodeAllocMap)
	__v := packPCharString(__ret)
	return __v
}
